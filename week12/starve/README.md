## 애노테이션 정의하는 방법

### 애노테이션이란?

- 프로그램의 소스코드안에 다른 프로그램을 위한 정보를 **약속된 형식으로 포함**시킨 것.
- 주석(comment)처럼 프로그래밍 언어에 영향을 미치지 않으며, 다른 프로그램에 유용한 정보를 제공하는 장점이 있음.
- 애노테이션의 조상인 Annotation인터페이스의 소스코드 중, '/**'로 시작하는 주석 안의 소스코드에 대한 설명을 적고, '@'이 붙은 태그들을 볼 수 있는다. 이는 정의된 태그를 이용해 주석 내의 정보를 저장하고, 이 정보를 javadoc.exe라는 프로그램이 문서를 작성하는 것에 사용되는 것이다. 그리고 이 기능을 응용하여 만들어 진 것이 애노테이션.
- 표준 애노테이션과 메타애노테이션이 존재한다.

### 표준 애노테이션

- 주로 컴파일러를 위한 것. 컴파일러에게 유용한 정보를 제공한다.

  | 애노테이션           | 설명                                                   |
  | -------------------- | ------------------------------------------------------ |
  | @Override            | 컴파일러에게 메서드를 오버라이딩 하는 것이라고 알린다. |
  | @Deprecated          | 앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.      |
  | @SupperessWarnings   | 컴파일러의 특정 경고메세지가 나타나지 않게 해준다.     |
  | @SafeVarargs         | 지네릭스 타입의 가변인자에 사용한다.(JDK1.7)           |
  | @FunctionalInterface | 함수형 인터페이스라는 것을 알린다.(JDK1.8)             |
  | @Native              | native메서드에서 참조되는 상수 앞에 붙인다.(JDK1.8)    |

### 메타 애노테이션

- 새로운 애노테이션을 정의할 때 애노테이션의 적용대상(target)이나, 유지기간(retention)을 지정하는 데 사용한다.
- 에너테이션을 위한 애노테이션.

| 애노테이션  | 설명                                                       |
| ----------- | ---------------------------------------------------------- |
| @Target     | 애노테이션이 적용 가능한 대상을 지정하는 데 사용한다.      |
| @Documented | 애노테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다. |
| @Inherited  | 애노테이션이 자손 클래스에 상속되도록 한다.                |
| @Retention  | 애노테이션이 유지되는 범위를 지정하는 데 사용한다.         |
| @Repeatable | 애노테이션을 반복해서 적용할 수 있게 한다.(JDK 1.8)        |

### 애노테이션 타입 정의하기

- 새로운 애노테이션을 정의하는 방법: '@'를 붙이는 것을 제외하면 인터페이스 정의와 동일하다.

  ```java
  @interface 애노테이션이름{
    타입 요소이름(); //애노테이션의 요소를 선언
    ...
  }
  ```



### 애노테이션 요소 정의하기

* 애노테이션의 요소는 메서드 형태로 선언하며, 기본형과 String 배열 등 기존 클래스들에서 선언하던 요소들을 그대로 사용 할 수 있다.
* 반환값은 있지만 매개변수는 없는 추상 메서드의 형태로 작성되며, 요소에 기본값을입력해 줄 수 있다.
  기본값 입력시, `Type 속성명() default <기본값>` 형태로 지정할 수 있으며, 애노테이션 사용 시 아무런 값 입력이 없을경우 기본값이 사용된다.
* 예외를 선언할 수 없으며, 제네릭 사용이 불가능하다. 



## `@retention`

#### @Retention

- 애노테이션이 유지(retention)되는 기간을 지정하는 데 사용한다.
- 애노테이션의 유지정책(retention policy)의 종류:
  - SOURCE:
    - 소스파일에만 존재. 클래스 파일에는 존재하지 않음.
    - 컴파일러가 사용하는 애노테이션의 유지정책. 컴파일러를 직접 작성할 것이 아니면, 이 유지정책은 필요없음.
    - '@Override', '@SuppresssWarnings'가 대표적 예시.
  - CLASS:
    - 클래스 파일에 존재. 실행시에 사용 불가. 기본값이다.
    - 컴파일러가 애노테이션의 정보를 클래스 파일에 저장할 수 있게 하지만, 클래스 파일이 JVM에 로딩될때 애노테이션의 정보가 무시되기 때문에, 기본값임에도 잘 사용되지 않는다.
  - RUNTIME:
    - 클래스 파일에 존재. 실행시에 사용 가능.
    - 실행 시, '리플렉션(reflection)'을 통해 클래스 파일에 저장된 애노테이션의 정보를 읽어 처리할 수 있다.
    - '@FunctionalInterface'는 'Override'처럼 컴파일러가 체크하지만, 실행 시에도 사용되므로 'RUNTIME'으로 되어 있다.





## `@target`

#### @Target

- 애노테이션이 적용 가능한 대상을 지정하는 데 사용한다.

- 애노테이션에 적용할 수 있는 대상을 지정한 예시: 이 또한 여러개를 이용하고 싶다면 대괄호를 이용해야한다.

  ```
  @Target({Type, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
  @Retention(RetentionPolicy.SOURCE)
  public @interface SuppressWarnings {
    String[] value();
  }
  ```

- @Target으로 지정할 수 있는 애노테이션 적용대상:

  | 대상 타입       | 의미                                                         |
  | --------------- | ------------------------------------------------------------ |
  | ANNOTATION_TYPE | 애노테이션                                                   |
  | CONSTRUCTION    | 생성자                                                       |
  | FIELD           | 필드(멤버변수, enum tkdtn)                                   |
  | LOCAL_VARIABLE  | 지역변수                                                     |
  | METHOD          | 메서드                                                       |
  | PACKAGE         | 패키지                                                       |
  | PRAMETER        | 매개변수                                                     |
  | TYPE            | 타입(클래스, 인터페이스, enum) 타입 선언 시, 애노테이션을 붙일 수 있다. |
  | TYPE_PRAMETER   | 타입 매개변수(JDK1.8)                                        |
  | TYPE_USE        | 타입이 사용되는 모든 곳(JDK1.8) 해당 타입의 변수를 선언할 때 붙일 수 있다. |

  - 표의 값들은 'java.lang.annotation.ElementType' 이라는 열거형에 정의 되어 있으며, 아래와 같이 static import 문 사용 시, Element.TYPE과 같은 것들을 위의 표 처럼 간단히 사용할 수 있다.

    ```java
    import java.lang.annotation.ElementType.*;
    
    @Target({TYPE, FIELD, TYPE_USE}) // 적용 대상이 TYPE, FIELD, TYPE_USE
    
    public @interface MyAnnotation { } // MyAnnotation을 정의
    
    @MyAnnotation // 적용 대상이 TYPE인 경우.
    class Myclass {
      @MyAnnotation // 적용 대상이 FIELD인 경우
      int i;
      
      @MyAnnotation  // 적용 대상이 TYPE_USE인 경우
      MyClass mc;
    }
    ```



## `@documented`

#### @Documented

- 애노테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.

- 자바에서 제공하는 기본 애노테이션 중, `@Override`, `@SuppresssWarnings`을 제외한 나머지는 모두 이 애노테이션이 붙어있다.

  ```java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target(ElementType.TYPE)
  public @interface FunctionalInterface{}
  ```

#### 

## 애노테이션 프로세서

* Annotation Processor는 컴파일 타임에 특정한 애노테이션이 붙어있는 소스코드를 참조할 수 있는 기능을 제공해준다.
* 정확하게는 컴파일 타임에 애노테이션들을 스캐닝하고, 프로세싱을 해주는 javac 소속 빌드 툴이다.
* 소스코드 레벨에서 애노테이션 정보를 읽어 컴파일러가 컴파일 도중 새로운 코드를 생성하거나, 기존의 코드를 변경 할 수 있게 한다.
* 애노테이션 프로세스는 자바 코드(혹은 컴파일된 바이트 코드)를 가지고 .java파일을 생성한다.
  이미 존재하는 java클래스를 조작해서 메소드를 추가할 수는 없지만 새로 생성된 자바파일은 javac에 의해 컴파일된다.
* 이 기능을 사용하는 대표적인 라이브러리중 하나는 롬복(lombok)이며, 
  사용자가 직접 자바 클래스 내에 getter, setter 를 추가하지 않아도 사용할 수 있도록 .java파일을 수정하여 생성해주는 모습을 쉽게 확인할 수 있다.
  이러한 모습을 보면 애노테이션 프로세서 개발자의 의도와는 다른, 일종의 해킹이라고도 볼 수 있을 것이다. 따라서 문제점이 있는 애노테이션이나, 편리함으로 인하여 개발자들이 자주 사용하고있다.