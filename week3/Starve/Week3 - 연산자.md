

- [비트 연산자](https://velog.io/@dion/백기선님-온라인-스터디-3주차-연산자#비트-연산자)
- [switch 연산자](https://velog.io/@dion/백기선님-온라인-스터디-3주차-연산자#switch-연산자)





* 연산자란, 연산을 수행하여 결과를 반환하는 기호를 의미한다.
* 연산자가 연산을 수행하는 데에 있어서 필요한 연산의 대상은, 피연산자(operand)라고 한다.
* 피연산자의 개수에 따라 단항연산자, 이항연산자, 삼항연산자 등으로 불리기도 한다.

## 산술 연산자

* 수학적인 계산에서 사용되는 연산자. 기본적인 수학지식과 마찬가지로, `곱셈, 나눗셈, 나머지 연산자`가 `덧셈,뺄셈 연산자`보다 우선 순위가 높다.

* 나눗셈 연산자에서 피연산자가 정수형일 경우, 0으로 나눌 수 없다. 
  실수형일 경우, Infinity, -Infinity, NaN 값을 가진다.

  | 기호 |  종류  |
  | :--: | :----: |
  |  +   | 더하기 |
  |  -   |  빼기  |
  |  *   | 곱하기 |
  |  /   | 나누기 |
  |  %   | 나머지 |

* 값을 계산하고자 하는 피연산자들의 타입이 일치해야 하므로, 타입이 서로 다를 경우 자동 형변환인`산술 변환`이 일어난다.

* 숫자 뿐만 아니라 문자나, 문자열타입 에도 사용 가능하다.



#### 부호 연산자

* 숫자 앞에 '-' 혹은 '+'를 붙이는 것을 의미한다. 숫자의 음수 값, 혹은 양수값을 의미하는 부호이다.
* '+' 부호 연산자의 경우, '-' 부호 연산자가 등록되어있기 때문에 함께 등록 된 것으로, 잘 쓰이지 않는다.
* boolean과 char형을 제외한 기본형 타입에만 사용할 수 있다.



#### 증감 연산자

* 숫자 앞, 혹은 뒤에 '++' 혹은 '--'를 붙이는 것을 의미한다.
  숫자 앞에 부호를 붙일 경우 전위형, 뒤에 붙일 경우 후위형이라고 한다.

* ex)

  ```java
  int prefix = 5;
  int postfix = 5;
  
  ++prefix; // 결과 값 6.
  postfix++; // 결과 값 5. 첫 호출 시에는 값이 변경되지 않는다. 
  
  int a = prefix; // 결과 값 6.
  int b = postfix; // 결과 값 6. 한 번 더 호출 될 경우 값이 변경되어 있다.
  ```

  

## 비트 연산자

* 정수 타입에 대해서 비트와 비트 시프트 연산을 제공하는데, 이를 비트 연산자라고 한다.

* 비트 연산이란? :
   정수타입의 2진수 조각 하나를 비트라고 표현하는데, 이 비트들의 연산을 수행하는 것을 의미한다.

  | 연산자 | 종류                                                         |
  | ------ | ------------------------------------------------------------ |
  | ~      | 비트를 반전시키는 단항 연산자. '0'은 '1', '1'은 '0'으로 반전시킨다.<br />ex) `00000000 -> 11111111`, `01010 -> 10101`<br />1의 보수를 만든다고도 표현한다. |
  | &      | AND연산의 표현인 이항 연산자. 피연산자들의 비트별로 AND연산을 수행한다. |
  | \|     | OR연산의 표현인 이항 연산자. 피연산자들의 비트별로 OR연산을 수행한다. |
  | ^      | XOR연산의 표현인 이항 연산자. 피연산자들의 비트별로 XOR연산을 수행한다.<br />두 값이 다를 때만 1이 된다. |


  | x    | y    | x \| y | x & y | x ^ y |
  | ---- | ---- | ------ | ----- | ----- |
  | 1    | 1    | 1      | 1     | 0     |
  | 1    | 0    | 1      | 0     | 1     |
  | 0    | 1    | 1      | 0     | 1     |
  | 0    | 0    | 0      | 0     | 0     |

* 비트 시프트 연산자:

  | 연산식  | 설명                                                         |
  | ------- | ------------------------------------------------------------ |
  | x << y  | 정수 x의 각 비트를 y 만큼 왼쪽으로 이동시킨다.(빈 자리는 0으로 채워짐.) |
  | x >> y  | 정수 x의 각 비트를 y 만큼 오른쪽으로 이동시킨다.(빈 자리는 정수 a의 <br />최상위 부호비트와 같은 값으로 채워짐. 양수는 0, 음수는 1) |
  | x >>> y | 정수 x의 각 비트를 y 만큼 오른쪽으로 이동시킨다.(빈 자리는 0으로 채워짐.) |

  * x << y 연산은 x * 2y 와 같으며, x >> y 연산은 x / 2n과 같다.
    시프트 연산을 사용하는 이유는, 산술 연산보다 더 속도가 빠르기 때문이지만 가독성이 떨어지므로 성능 개선이 필요한 부분에서만 사용해야한다.



## 관계 연산자

* 두 개의 피연산자를 비교하는데에 사용되는 연산자. 비교 연산자라고도 한다.

* 조건문이나 반복문의 조건식에서 사용되며, 연산 결과는 boolean인 true, false로 반환된다.

* 관계 연산자 역시 피연산자들의 타입이 다를경우 자동 형변환을 한다.


| 관계 연산자 | 연산결과                                     |
| ----------- | -------------------------------------------- |
| >           | 좌변의 값이 크면 true, 아니면 false          |
| <           | 좌변의 값이 작으면 true, 아니면 false        |
| >=          | 좌변의 값이 크거나 같으면 true, 아니면 false |
| <=          | 좌변의 값이 작거나 같으면 true, 아니면 false |
| ==          | 두 값이 같으면 true, 아니면 false            |
| !=          | 두 값이 다르면 true, 아니면 false            |

* 문자열의 경우, 비교할 때 == 대신 `.equals()` 혹은 `.equalsIgnoreCase()` 를 사용한다.
  두 가지의 차이점은 `.equals()` 의 경우, 대소문자를 구분하기 때문에 완벽이 같지 않으면 false를 반환하며, `.equalsIgnoreCase()` 의 경우 대소문자를 구분하지 않는다.



## 논리 연산자

* 'x가 4보다 작거나 10보다 크다'와 같이 두 개의 조건이 결합 된 경우 사용하는 연산자.

  | 종류           | 연산 결과                                         |
  | -------------- | ------------------------------------------------- |
  | \|\| (OR 결합) | 피연산자 중 어느 한쪽이 true면 true, 아니면 false |
  | &&(AND 결합)   | 피연산자 중 양쪽이 true면 true, 아니면 false      |



#### 논리 부정 연산자

* 피연산자가 true라면 false를, false라면 true를 반환하는 단항 연산자이다.
* 사용하는 방법은 단항 연산자 boolean 값의 앞에 !를 붙이면 된다.



## instanceof

* 객체가 특정 클래스 / 인터페이스 유형인지의 여부를 확인하여, 여부를 true 혹은 false로 알려준다.

* 부모 객체의 인스턴스인지, 아니면 자식 객체인지의 여부를 알려준다.

  ```java
  class A {}
  
  class B extends A {}
  
  public static void main(String[] args) {
  
      A a = new A();
      B b = new B();
      
      System.out.println(a instanceof A); // true
      System.out.println(b instanceof A); // true
      System.out.println(a instanceof B); // false
      System.out.println(b instanceof B); // true
  
  }
   
  ```

  

## assignment(=) operator

* 대입 연산자, 혹은 할당 연산자라고도 한다. 오른쪽의 값을 연산자 왼쪽의 피연산자에 할당한다.

* ex )

  ```java
  int x = 0; // x라는 변수에 0이라는 int형 리터럴을 할당했다.
  
  Human human = new Man(); // 인스턴스의 참조를 타입 참조 변수에 할당했다. 
  ```

* 대입 연산자의 왼쪽 피연산자를  'lvalue', 오른쪽 피연산자를 'rvalue'라고 하는데,
  lvalue의 경우 반드시 변수처럼 값을 변경할 수 있어야 한다.

* ex )

  ```java
  int i = 0;
  3 = i+3; // lvalue가 값을 저장할 수 없는 공간이기 때문에 불가능하다.
  i+3 = i; // lvalue의 연산 결과가 리터럴이기 때문에 불가능하다.
  ```



#### 복합 대입 연산자

* 다른 연산자와 대입 연산자를 결합하여 사용하는 것.

  | op=         | =                |
  | ----------- | ---------------- |
  | i += 3      | i = i + 3        |
  | i -= 3      | i = i - 3        |
  | i *= 3      | i = i * 3        |
  | i /= 3      | i = i / 3        |
  | i %= 3      | i = i % 3        |
  | i <<= 3     | i = i << 3       |
  | i >>= 3     | i = i >> 3       |
  | i &= 3      | i = i & 3        |
  | i ^= 3      | i = i ^ 3        |
  | i \|= 3     | i = i ; 3        |
  | i *= 10 + j | i = i * (10 + j) |

  



## 화살표(->) 연산자

* JAVA 8버전 이후 부터 화살표 연산자는 람다식을 도입할 때 사용되는 연산자로, 람다 표현식이라고도 한다.

* 익명 함수 또는 함수 인터페이스를 구현하는익명 클래스의 인스턴스를 간단하게 표현해 줄 수 있다.

  ```java
  (파라미터) -> {Body}
  a -> a+1;
  ```

* @FunctionalInterface 애노테이션을 붙인 인터페이스의 구현체로도 사용할 수 있다.



## 3항 연산자

* 자바에서 유일하게 피연산자를 세 개 가지는 조건 연산자다.
* if-else문과 비슷하지만 한 줄로 표현할 수 있다.
* `조건식 ? 반환값1 : 반환값 2` 와 같은 형식으로 사용하며, true일 경우 반환값 1을, false일 경우 반환값 2를 반환한다.



## 연산자 우선 순위

* 연산자 우선 순위는 식을 평가 할 때 많은 영향을 미치는데, 이는 우선 순위에 따라 프로그램이 의도와 다르게 동작할 수 있기 때문이다.

* 우선수위 표:
  위로 올라갈 수록 높으며, 아래로 내려갈 수록 우선순위가 낮다.

  | 연산자                                                    | 연산 방향 |
  | --------------------------------------------------------- | --------- |
  | 증감(++, --), 부호(+, -), 비트(~), 논리(!)                | ⬅️         |
  | 산술(*, /, %)                                             | ➡️         |
  | 산술(+, -)                                                | ➡️         |
  | 쉬프트(<<, >>, >>>)                                       | ➡️         |
  | 비교(<, >, <=, >=, instanceof)                            | ➡️         |
  | 비교(==, !=)                                              | ➡️         |
  | 논리(&)                                                   | ➡️         |
  | 논리(^)                                                   | ➡️         |
  | 논리(\|)                                                  | ➡️         |
  | 논리(&&)                                                  | ➡️         |
  | 논리(\|\|)                                                | ➡️         |
  | 조건(?:)                                                  | ➡️         |
  | 대입(=, +=, -+, *=, /=, %=, &=, ^=, \|=, <<=, >>=, >>>= ) | ⬅️         |

  



## Java 13. switch 연산자

* if문과 같은 조건문에서 사용되는 switch/case문이 switch 연산자다.

* 입력 값이 정형화 되어있고 조건이 많은 경우, if문 보다 switch/ case문을 쓰는 것이 가독성에 유리하다는 장점이 있다.

  ```java
  int num;
  switch(num) {
    case 0 :
      System.out.println(0);
      
    case 1 :
      System.out.println(1);
  }
  
  System.out.println(
    switch (num) {
      case 0 -> 0;
      case 1 -> 1;
    }
  );
  
  int sum += switch (num) 
    {
      case 0 -> 0;
      case 1 -> 1;
    }
  ```

  > 위의 경우, case 0 에 break를 해주지 않을 경우, 원하던 값이 나오지 않을 수도 있으나, 
  > 아래와 같이 arrow case 레이블을 사용할 경우, break문을 사용하지 않아도 아래로 떨어지거나 하지 않는다. 변수에 등록할때도 아래와 같이 사용하면 된다.

