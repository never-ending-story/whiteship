- [Thread 클래스와 Runnable 인터페이스](#Thread-클래스와-Runnable-인터페이스)
- [쓰레드의 상태](#쓰레드의-상태)
- [쓰레드의 우선순위](#쓰레드의-우선순위)
- [Main 쓰레드](#Main-쓰레드)
- [동기화](#동기화)
- [데드락](#데드락)



## 들어가기 전

#### 프로세스(process)와 쓰레드(thread)

- 프로세스(process):

  - 메인 메모리에 적재되어 실행중인 프로그램(program)

    프로그램을 실행하면, OS로 부터 실행에 필요한 자원(메모리)를 할당받아 프로세스가 된다.

  - 프로그램을 수행하는데 필요한 데이터와 메모리 등의 자원, 쓰레드로 구성되어있다.

  - 최소 하나 이상의 쓰레드가 존재하며, 두 개이상의 쓰레드를 가진 프로세스를 

    **'멀티 쓰레드 프로세스(multi-thread process)'**라 한다.

- 쓰레드(thread):

  - 프로세스의 자원을 이용하여 실제로 작업을 수행하는 최소 단위.
  - 모든 프로세스는 최소 하나 이상의 쓰레드가 존재한다.
  - 가벼운 프로세스(경량 프로세스 LWP: light - weight process)라고 부르기도 한다.

- 프로세스는 공장, 쓰레드는 일꾼으로 생각한다면 이해하기가 쉽다.

#### * 멀티 쓰레딩의 장단점

- 멀티 쓰레딩의 장점:

  - CPU의 사용률을 향상시킨다.
  - 자원을 효율적으로 사용할 수 있다.
  - 사용자에 대한 응답성이 향상된다.
  - 작업이 분리되어 코드가 간결해진다.

- 멀티 쓰레딩의 단점:

  - 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하며 사용하기 때문에, **동기화(synchronization), 교착상태(deadlock)**와 같은 문제를 고려해서 **신중히 프로그래밍** 해야한다.

- 멀티 쓰레딩의 예:

  - 도스(DOS)와 달리 윈도우의 경우 같은 OS인데, 윈도우는 멀티태스킹이 가능하다. 이는 싱글 쓰레드와 멀티 쓰레드 프로그램의 차이와 같다.

  - 메신저로 채팅하며 파일을 다운로드 하거나 하는 등의 멀티태스킹이 가능한 이유가, 멀티 쓰레드로 작성되어있기 때문에. 싱글 쓰레드는 이러한 작업이 불가능 하여, 서버 프로그램의 경우 멀티 쓰레드로 작성하는 것은 필수적이다.

    > 하나의 서버 프로세스가 여러 쓰레드를 생성해, 쓰레드와 사용자의 요청이 일대일로 처리되도록 해야한다.
    >
    > 이를 싱글 쓰레드로 작성 할 경우, 많은 시간과 메모리가 필요하기 때문에 많은 수의 사용자 요청을 서비스 하기 어렵다.

## 

## Thread 클래스와 Runnable 인터페이스

#### 쓰레드를 구현

- 쓰레드를 구현하는 법으로는  Tread 클래스를 상속 받는 방법과, Runnable인터페이스를 구현하는 두 가지 방법이 있으며,두 가지의 방법 중 어떤 것을 사용 하여도 괜찮고 둘 다 추상메서드인 run()의 몸통{}을 채우면 된다.

  1. Tread 클래스를 상속

     - 다른 클래스를 상속받을 수 없다.

     ```java
     class MyThread extends Thread {
       public void run() { /* 작업 내용 */ } //Thread클래스의 run()을 오버라이딩
     }
     ```

  2. Runnable인터페이스를 구현

     - 일반적으로 사용하는 방법.
     - 재사용성(resuability)이 높고 코드의 일관성(consistency)을 유지할 수 있다. 보다 객체지향적인 방법.

     ```java
     class MyThread implements Runnable {
       public void run() { /* 작업 내용 */ } //Runnable 인터페이스의 run()을 구현
     }
     ```

     - 오로지 run()만 정의 되어있는 간단한 인터페이스로, 구현하기 위해서는 추상메서드인 run()의 몸통{}을 만들어 주는 것만 하면 된다.

       ```java
       public interface Runnable{
         public abstruct void run();
       }
       ```

- thread 와 runnable의 차이점

  * Thread 클래스를 확장하여 생성된 각 쓰레드는 고유한 객체를 만들어 해당 객체와 연관을 시켜 사용하는 반면에,
    Runnable 인터페이스를 구현해 생성된 각 쓰레드는 실행 가능 한 인스턴스를 공유하여 사용한다.
  * 쓰레드 클래스를 확장하여 각 쓰레드가 생성 될 때, 고유한 객체와 연관 시키므로 메모리가 더 많이 필요하다.
    Runnable 인터페이스를 구현해 생성돤 각 쓰레드는, 같은 오브젝트 공간을 공유하여 사용하기 때문에 메모리가 더 적게 소모된다.
  * Thread 클래스를 확장할 경우, 다중 상속을 허용하지 않아 다른 클래스를 상속받을 수 없지만, 
    Runnable 인터페이스의 경우 다른 클래스를 상속 받을 수 있다.
  * Thread 클래스의 다른 메소드를 오버라이드 하거나 특수화하고자 할 때만 Thread 클래스를 확장해야한다. run메소드만 특수화 하려면 Runnable 인터페이스를 구현해야한다.
  * Thread 클래스를 확장하면, Thread 클래스의 코드와 Thread 클래스의 작업이 동일한 클래스에 포함되므로 코드에서 밀접하게 결합되는 반면, Runnable 인터페이스의 구현은 쓰레드 코드가 쓰레드에 할당 된 작업에서 분리되므로 코드에서 느슨하게 결합된다.

  

  #### start()와 run()

  - start()와 run()의 차이

    - run():

      - 생성된 쓰레드를 실행시키는 것이 아닌, 클래스에 선언된 메서드를 호출 하는 것.

        새로운 쓰레드는 실행시키지 않는다.

    - start():

      - 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택(call stack)을 생성한 다음, run()을 호출해, 생성된 호출스택에 run()이 첫 번째로 올라가게 한다.
      - 모든 쓰레드는 독립적인 작업을 수행하기 위해, 호출스택을 필요로한다. 새로운 쓰레드를 생성하고 실행시킬 때 마다 호출스택이 새롭게 생성되고, 쓰레드 종료 시 사용한 호출스택 또한 소멸된다.
      - 두 번 start() 메서드를 호출할 경우 Exception이 발생한다.

  - 쓰레드가 실행되는 과정

    1. main메서드에서 쓰레드의 start()를 호출한다. [![스크린샷 2021-01-02 오후 6 37 56](https://user-images.githubusercontent.com/69128652/103454664-a3151d80-4d29-11eb-8885-93d66782c8f7.png)](https://user-images.githubusercontent.com/69128652/103454664-a3151d80-4d29-11eb-8885-93d66782c8f7.png)
    2. start()는 새로운 쓰레드를 생성 후, 쓰레드가 작업하는데 사용될 호출 스택 생성 [![스크린샷 2021-01-02 오후 6 38 39](https://user-images.githubusercontent.com/69128652/103454679-bd4efb80-4d29-11eb-9075-b607815dea5c.png)](https://user-images.githubusercontent.com/69128652/103454679-bd4efb80-4d29-11eb-9075-b607815dea5c.png)
    3. 새로 생성된 호출스택에 run()이 호출되어, 쓰레드가 독립적인 작업을 수행. [![스크린샷 2021-01-02 오후 6 39 05](https://user-images.githubusercontent.com/69128652/103454686-ccce4480-4d29-11eb-8b9d-a4b3b0ca0d21.png)](https://user-images.githubusercontent.com/69128652/103454686-ccce4480-4d29-11eb-8b9d-a4b3b0ca0d21.png)
    4. 호출스택이 2개이므로, 스케줄러가 정산 순서에 의해 번갈아 가며 실행. [![스크린샷 2021-01-02 오후 6 39 26](https://user-images.githubusercontent.com/69128652/103454689-d9529d00-4d29-11eb-8f0b-7cf5797c738d.png)](https://user-images.githubusercontent.com/69128652/103454689-d9529d00-4d29-11eb-8f0b-7cf5797c738d.png)

  ### 

## 쓰레드의 상태

| 상태                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| NEW                   | 쓰레드가 생성되었지만, start()가 호출 되지 않은 상태         |
| RUNNABLE              | 실행 중 또는 실행 가능한 상태                                |
| BLOCKED               | 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴 때 까지 대기 상태) |
| WAITING, TIMED_WATING | 쓰레드 작업이 종료되지는 않았지만 실행이 가능하지 않은 일시정지 상태(UNRUNNABLE). TIME_WAITING 은 일시정지 시간이 정해진 경우(타이머 인터럽트) |
| TERMINATED            | 쓰레드의 작업이 종료된 상태                                  |

- 쓰레드 상태 변화 과정:
  1. 쓰레드가 생성 된 후(NEW), start() 호출 시, 실행 대기열에 저장되어 자신의 순번을 기다린다. 이 때, 실행 대기열은 큐(Queue)의 구조와 같아, 먼저 들어온 쓰레드가 먼저 실행됨.
  2. 실행 순번이 돌아왔을 경우, 실행상태로 변경.
  3. 주어진 실행시간이 완료되거나, yield()(쓰레드 양보)를 만날 경우 실행 대기 상태로 돌아가며, 이후 순번의 쓰레드가 실행상태가 됨.
  4. 쓰레드 실행 도중, suspend(), sleep(), wait(), join()(쓰레드 합류), I/O block(입출력 작업에서 발생되는 지연상태. 사용자 입력 대기 등을 의미.)에 의해 일시정지 상태가 될 수 있다.
  5. 지정된 일시정지 시간(time-out)이 다되거나, notify(), resume(), interrupt() 호출 시, 일시정지 상태에서 벗어나, 실행대기열에 저장되어 다시 순번을 기다림.
  6. 실행이 완료 되거나, stop() 호출 시, 쓰레드 소멸.



#### * 쓰레드 실행제어

- 효율적인 멀티쓰레드 프로그램을 만들기 위해서는, 정교한 스케줄링(scheduling)을 통해 프로세스에게 주어진 자원과 시간을 여러 쓰레드가 낭비없이 사용하도록 프로그래밍 해야된다.

  > 쓰레드 프로그래밍이 어려운이유는, 동기화(synchronization)과 스케줄링(scheduling)때문이다.

- 쓰레드 스케줄링 메서드:

  | 메서드                                                       | 설명                                                         |
  | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | static void sleep(long millis) static void sleep(long millis, int nanos) | 지정된 시간(천분의 일초 단위)동안 쓰레드를 일시정지시킴. 지정한 시간 후에는 자동적으로 다시 실행대기 상태가 됨. |
  | void join() void join(long millis) void join(long millis, int nanos) | 지정된 시간동안 쓰레드가 실행됨. 지정된 시간이 지나거나 작업 종료시, join()을 호출한 쓰레드로 돌아와 실행을 계속함. |
  | void interrupt()                                             | sleep()이나 join()에 의해 일시정지상태인 쓰레드를 깨워서 실행대기 상태로 만듬. 해당 쓰레드에서는 intterupted Exception이 발생함으로써 일시정지 상태 벗어남. |
  | void stop()                                                  | 쓰레드 즉시 종료                                             |
  | void suspend()                                               | 쓰레드를 일시정지 시킴. resume() 호출 시, 다시 실행대기 상태로 돌아간다. |
  | void resume()                                                | suspend()에 의해 일시정지 상태가 된 쓰레드를 실행대기 상태로 만듬. |
  | static void yield()                                          | 실행 중, 주어진 실행시간을 다른 쓰레드에게 양보(yield)하고, 자신은 실행대기 상태가 됨. |

## 쓰레드의 우선순위

- 쓰레드는 우선순위(priority)라는 속성(멤버변수)을 가지고 있는데, 이 우선순위의 값에 따라 얻는 실행시간이 달라진다.
- 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 다르게 하여 특정 쓰레드의 작업시간을 더 많이 갖도록 할 수 있다.
  - 시각적인 부분이나, 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선순위는 다른 쓰레드 보다 높아야한다.
     (ex. 파일 전송 기능이 있는 메신저의 경우, 메세지 발송 쓰레드의 우선순위가 높아야 채팅하는 것에 불편함이 없다.)

#### 우선순위 지정하기

```java
void setPriority(int newPriority) // 쓰레드의 우선순위를 지정한 값으로 변경한다.
int  getPriority()								// 쓰레드의 우선순위를 반환한다.

public static final int MAX_PRIORITY = 10 // 최대 우선순위
public static final int MIN_PRIORITY = 1  // 최소 우선순위
public static final int NORM_PRIORITY = 5 // 보통 우선순위
```

- 우선순위의 범위는 1~10이며, 숫자가 높을수록 우선순위가 높음. 기본값은 5이다.

- 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받으며, 

  main메서드를 수행하는 쓰레드는 우선순위가 5이므로, main메서드 내에서 생성하는 우선순위는 자동적으로 5가 된다.

- 가장 낮은 우선순위인 1순위 쓰레드도 아주 잠깐씩 자원을 받아서 실행된다.

  * 우선 순위가 높은 쓰레드가 자주 실행 되는 경향을 보이는 이유는, JVM 내부의 쓰레드 스케줄러가 우선순위별로 Time slice를 분배하는 방식으로 우선순위를 활용하기 때문이다.
    이를 순환 할당(Round-Robin)이라고 한다.
  * 순환 할당:
    * 시간을 짧게 쪼개고(Time을 Slicing해서) 짧은 한 단위의 시간(10ms~50ms 플랫폼별로 다름) 마다 쓰레드들에게 실행할수 있도록 자원을 할당해 주는 방식.
    * 한 단위의 시간(1Slicing Time)이 지나면 Java의 쓰레드 스케줄러가 점지해준 쓰레드를 실행.
    * 이 스케쥴링 알고리즘은 자바 가상 머신(JVM)에 의해서 정해지기 때문에 코드로 제어할 수 없다.

  

  ### 동시성과 병렬성

  - **동시성 (Concurrency)**

    : 동시성이란, 코어 1개가 여러개의 쓰레드 작업 테이블을 왔다 갔다 하면서 작업을 하는 것이다. 보통 쓰레드의 개수가 코어의 갯수 보다 많을 경우, 동시성으로 멀티 쓰레드를 지원하게 된다.

  - **병렬성 (Parallelism)**

    : 병렬성은 코어 개수가 많거나 작업을 해야할 쓰레드의 갯수보다 코어가 더 많은 경우로, 각 코어마다 task Thread 를 할당 받아서 작업하게 되는데, 동시에 여러 쓰레드가 병렬적으로 동작하기 때문에 병렬적으로 일이 처리되어 병렬성이라 부른다.

  

## Main 쓰레드

- main 메서드의 작업을 수행하는 것도 쓰레드다. 이를 main쓰레드라고 한다.

- 프로그램을 실행하면 기본적으로 하나의 쓰레드를 생성하고, 그 쓰레드가 main메서드를 호출해서 작업이 수행되도록 하는 것이다.

  [![스크린샷 2021-01-02 오후 6 47 50](https://user-images.githubusercontent.com/69128652/103454827-05225280-4d2b-11eb-9dac-8633706e097a.png)](https://user-images.githubusercontent.com/69128652/103454827-05225280-4d2b-11eb-9dac-8633706e097a.png)

  - main메서드가 수행을 마쳤다고 하더라도, 다른 쓰레드가 아직 작업을 마치지 않았다면 프로그램이 종료되지 않는다.

    > 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.

- 쓰레드의 종류는 '사용자 쓰레드(user thread)'와 '데몬 쓰레드(daemon thread)'가 있는데, 사용자 쓰레드는 'non-daemon thread'라고도 한다.



## 동기화

- 멀티 쓰레드를 사용하는 프로세스의 경우, 프로세스의 자원을 공유하여 사용하는 멀티 쓰레드 특성 상, 서로의 작업에 영향을 주게 된다.

- 예시로, 쓰레드 A의 작업 도중 다른 쓰레드에게 제어권이 넘어가게 되었을 때, 그 쓰레드가 공유 데이터를 임의로 변경한다면 쓰레드 A가 나머지 작업을 처리할 때, 원래 의도와 다른 결과를 얻을 수 있다.

  - 이런 일을 방지하기 위해, 한 쓰레드가 특정 작업을 마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 도입된 개념이 '임계영역(critical section)'과 '잠금(lock)'이다.

- 한 쓰레드가 진행중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는것을 '쓰레드의 동기화(synchronization)' 라고 한다.

  > 공유데이터를 사용하는 코드를 임계 영역으로 잡아놓고, lock을 획득한 쓰레드만 이 영역 내의 코드를 수행하고, 모든 코드 수행 시 lock을 반납해야만 다른 쓰레드가 lock을 획득하여 임계영역의 코드를 수행하는 식. 공중화장실과 같은 것으로 생각하면 더욱 이해가 쉽다.

- synchronized 블럭으로 동기화 지원이 되고, JDK1.5 부터 'java.util.concurrent.lock', 'java.util.concurrent.atomic'패키지를 통해서도 동기화를 구현할 수 있다.

#### synchronized를 이용한 동기화

- 이 키워드는 임계 영역을 설정하는 데 사용되며, 두가지 방식이 있다.

  1. 메서드 전체를 임계 영역으로 지정

     ```
     public synchronized void calcSum(){
       //...
     }
     ```

     - 메서드 앞에 synchronized를 붙여서 사용. 메서드 전체가 임계 영역으로 설정되며, synchronized메서드가 호출된 시점부터 lock을 얻어 수행 후, 메서드 종료 시 lock을 반환.

  2. 특정한 영역을 임계 영역으로 지정

     ```
     synchronized(객체의 참조변수){
       // ...
     }
     ```

     - 메서드 내의 코드 일부를 블럭으로 감싸고, 블럭 앞에 synchronized(참조변수)를 붙이는 것. 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다.
     - 이 블럭을 synchronized블럭이라고 부르며, 블럭의 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 lock을 얻게 되고, 블럭을 벗어날 때 lock을 반납한다.

- 두 방식 모두 lock을 반환하고 얻는 과정은 자동이므로, 임계 영역만 지정해주면 된다. 메서드 전체에 락을 거는 것 보다, synchronized블럭으로 임계 영역을 최소화 하여 효율적인 프로그램이 되도록 하는 것이 좋다.



#### wait()과 notify()

- synchronized로 동기화 하여 공유 데이터를 보호할 때, 특정 쓰레드가 객체의 락을 오래 점유하지 않도록 하는 것이 중요하다. 이렇게 점유 하게 되면, 다른 쓰레드가 점유가 해제되기만을 기다리느라 다른 작업을 원활히 처리 할 수 없기 때문.
- 이러한 상황을 개선하기 위해 나온 것이 wait()과 norify()이다. 코드 수행 중, 더이상 진행할 수 없을 경우 wait()을 호출하여 락을 반납 후 기다리게 한다. 이후 다시 작업을 진행 할 수 있는 상황이 되면 notify()를 호출하여 다시 락을 얻어 작업을 진행할 수 있게 한다.
- wait(), notify(), notifyAll()
  - Object에 정의 됨.
  - 동기화 블록(synchronized블록)내에서만 사용 가능.
  - 효율적인 동기화를 가능하게 한다.

> waiting pool은 모든 객체마다 존재하므로, notifyAll()이 호출한다고 모든 객체의 waiting pool의 쓰레드가 깨워지는 것은 아니다.

## 데드락

* 두 개 이상의 쓰레드가 서로를 계속해서 기다리며 block 되어있는 상황을 의미한다.

* A와 B는 친구이지만 친구 관계에서의 예의를 중시하고 있다. 예의란, 친구에게 인사를 할 때 친구가 인사를 할 때 까지 인사를 유지하고 있어야 한다는 것이다.

  하지만 이 규칙은 두 친구가 동시에 서로에게 인사하는 가능성은 설명하지 않고 있다.

  ```java
  public class Deadlock {
      static class Friend {
          private final String name;
          public Friend(String name) {
              this.name = name;
          }
          public String getName() {
              return this.name;
          }
          public synchronized void hello(Friend bower) {
              System.out.format("%s: %s"
                  + "  has bowed to me!%n", 
                  this.name, bower.getName());
              bower.bowBack(this);
          }
          public synchronized void helloBack(Friend bower) {
              System.out.format("%s: %s야 안녕!%n",
                  this.name, bower.getName());
          }
      }
  
      public static void main(String[] args) {
          final Friend A =
              new Friend("A");
          final Friend B =
              new Friend("B");
          new Thread(new Runnable() {
              public void run() { A.hello(gaston); }
          }).start();
          new Thread(new Runnable() {
              public void run() { B.hello(alphonse); }
          }).start();
      }
  }
  ```

  * `Deadlock`을 실행하면, `helloBack`을 호출하려고 할 때 두 쓰레드가 모두 block될 가능성이 매우 높다. 각 쓰레드는 다른 쓰레드의 `hello`가 끝나길 기다리고 있기 때문에 끝나지 않는다.

### DeakLock 발생 조건

- **상호 배제 (Mutual Exclusion)** : 한 자원에 대해 여러 쓰레드 동시 접근 불가
- **점유와 대기 (Hold and Wait)** : 자원을 가지고 있는 상태에서 다른 쓰레드가 사용하고 있는 자원 반납을 기다리는 것
- **비선점 (Non Preemptive)** : 다른 쓰레드의 자원을 실행 중간에 강제로 가져올 수 없음
- **환형대기 (Circle Wait)** : 각 쓰레드가 순환적으로 다음 쓰레드가 요구하는 자원을 가지고 있는 것

위의 4가지 조건을 모두 충족할 경우 데드락이 발생하게 되기 때문에, 

위 4가지 중 하나라도 충족하지 않을 경우 데드락을 해결할 수 있다는 뜻이기도 하다.

> 공유 자원의 순서를 부여하거나, 동기화가 필요한 임계영역 내부에 다른 공유 자원을 부르지 않는 등의 방법으로 데드락을 해결 할 수 있다.