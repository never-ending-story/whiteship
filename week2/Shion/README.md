### 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

| 데이터 타입 | 표현 가능 범위 | 기본값 | byte | bit |
|-|-|-|-|-|
| boolean | false, true | false | 1 | 8 |
| char | '\u0000' ~ '\uffff' (0~2<sup>16</sup>-1, 0~65535) | \u0000 | 2 | 16 |
| byte | -128 ~ 127 (-2<sup>7</sup>~2<sup>7</sup>-1) | 0 | 1 | 8 |
| short | -32,768 ~ 32,767 (-2<sup>15</sup>~2<sup>15</sup>-1) | 0 | 2 | 16 |
| int | -2,147,483,648~2,147,483,647 (-2<sup>31</sup>~2<sup>31</sup>-1) | 0 | 4 | 32 |
| long | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (-2<sup>63</sup>~2<sup>63</sup>-1) | 0L | 8 | 64 |
| float | 1.4E-45 ~ 3.4E38 (1.4*10<sup>-45</sup>~3.4*10<sup>38</sup>) | 0.0f | 4 | 32 | 
| double | 4.9E-324 ~ 1.8E308 (4.9*10<sup>-324</sup>~1.8*10<sup>308</sup>) | 0.0 | 8 | 64 |

### 2. 프리미티브 타입과 레퍼런스 타입
- 프리미티브 타입 : 
  - 자바가 사전에 정의한 타입으로 1. 에서 언급된 8가지 타입이다. 프리미티브 타입은 스택에 생성된 실제 값을 저장한다.

- 레퍼런스 타입 : 
  - 프리미티브 타입을 제외한 모든 타입으로 사용자가 정의한 타입이다. 레퍼런스 타입의 변수에는 힙에 생성된 객체의 주소 값을 저장한다.

### 3. 리터럴
- 고정된 값(상수)으로 코드에서 별다른 계산없이 나타낼 수 있다.
- 아래와 같이 프리미티브 타입의 변수에 할당할 수 있다.
```java
boolean result = true;
char capitalC = 'C';
byte b = 100;
short s = 10000;
int i = 100000;
```
- 리터럴에 접미사를 붙여서 타입을 구분한다.
- byte, short, int타입의 변수에는 int타입의 리터럴을 사용한다. (byte, short 타입은 따로 없다)
- long타입의 리터럴에는 'l' 또는 'L'을 붙인다.
- 리터럴 앞에 접두사를 붙여서 16진수, 8진수, 2진수를 저장할 수 있다.
```java
int octNum = 010;  // 8
int hexNum = 0x10; // 16
int binNum = 0b10; // 2
```
- float타입의 리터럴에는 접미사 'f' 또는 'F'를 붙인다.
- double타입의 리터럴에는 'd' 또는 'D'를 붙이는데 실수는 double이 기본이기 떄문에 생략 가능하다.

### 4. 변수 선언 및 초기화하는 방법
```java
int a; // 변수 선언
a = 10; // 변수 초기화

int a = 10; // 변수 선언과 초기화를 동시에 진행
```

- 멤버변수는 선언하고 초기화 해주지 않을 경우 각 타입의 기본값으로 자동 초기화된다.
- 지역변수는 선언하고 사용하기전에 반드시 초기화해주어야 한다.

### 5. 변수의 스코프와 라이프타임
- 지역변수 : 메소드 블록내에 선언된 변수로, 메소드가 호출되어 스택에 올라갈 때 생성되며 호출을 마치고 스택에서 내려갈 때 사라진다.
- 인스턴스변수 : 객체가 생성될 때 힙 영역에 생성되며 해당 객체를 참조하는 변수가 더 이상 없을 때 Garbage Collector에 의해 객체와 함께 사라진다.
- 스태틱변수 : 모든 객체에서 접근할 수 있다. 프로그램이 시작되고 클래스 파일이 로딩되는 시점에 메소드영역에 생성되며 프로그램이 종료될 때 사라진다.

### 6. 타입 변환, 캐스팅 그리고 타입 프로모션
1. 기본형의 형변환

- 컴퓨터는 같은 타입끼리만 계산할 수 있어서, 연산할 때 피연산자의 타입이 서로 다르다면 먼저 타입을 일치시켜줘야 한다.
- 두 연산자의 타입을 일치시키는데 값 손실이 적게하기 위해서 범위가 큰 쪽으로 자동으로 일치시킨다.

    (산술변환)

```java
long + int -> long + long -> long

float + int -> float + float -> float // float과 int 모두 4바이트지만 실수가 정수보다 범위가 크다.

byte + short -> int + int -> int // int보다 작은 타입은(byte, short, char) int로 바뀌어서 연산된다.
```

- 범위가 작은 쪽으로 강제 형변환한다면 값손실이 있을 수 있다.

```java
float f = 1.2345;
(int)f -> 1;
```

2. 참조형의 형변환

- 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있다.

```java
class Human {}
class Man extends Human {}
class Woman extends Human {}

Human shion = new Man(); // 타입프로모션, Human의 범위가 Man의 범위보다 크기 때문에 자동으로 형변환
Man shion = (Man) new Human(); // 캐스팅, 범위가 큰 타입(Human)에서 작은 타입(Man)으로 형변환, 개발자가 명시(강제)해줘야 한다.
```

### 7. 1차 및 2차 배열 선언하기
```java
1차원 배열

타입[] 변수이름;          // 배열 선언(배열을 다루기 위한 참조변수 선언)
변수이름 = new 타입[길이]; // 배열 생성(실제 저장공간 생성)

int[] score;          // int타입의 배열을 다루기 위한 참조변수 score선언 
score = new int[5];   // int타입의 값 5개를 저장할 수 있는 배열 생성(타입의 기본값이 자동 저장)

int[] score = new int[5]; // 한줄로 표현

// 배열 초기화 1
score[0] = 50;   // 각 요소에 직접 값을 저장한다.
score[1] = 60;
score[2] = 70;
score[3] = 80;
score[4] = 90;

// 배열 초기화 2 (배열의 길이가 큰 경우와 일정한 규칙이 있을 때)
for (int i = 0; i < score.length; i++) {
		score[i] = i * 10 + 50;
}

// 배열 초기화 3
int[] score = new int[]{50, 60, 70, 80, 90} // 배열 생성과 초기화를 동시에
int[] score = {50, 60, 70, 80, 90}          // new int[] 생략 가능

--------------------------------------------------------------------

2차원 배열

타입[][] 변수이름;  // 2차원 배열 선언 
타입 변수이름[][]; 
타입[] 변수이름[];

int[][] score
int score[][]
int[] score[]

int[][] score = new int[4][3]; // 4행 3열의 2차원 배열을 생성

int[][] arr = new int[][]{ {1, 2, 3}, {4, 5, 6} };
int[][] arr = { 
									{1, 2, 3}, 
									{4, 5, 6} 
							}; // new int[][] 생략 가능

```

### 8. 타입 추론, var
- 타입추론이란 코드 작성 당시 타입을 정해지지 않았지만, 컴파일러가 그 타입을 유추하는 것이다. (제네릭과 람다식에서 사용)
- 자바 10부터 타입추론을 지원하는 var가 생겼다.

```java
var message = "Hello Java 10"; 
```

- message의 타입을 제공하지 않고 var로 인식한 후 컴파일러가 오른쪽의 초기화값으로 message의 타입을 추론한다. (String)
- var는 초기화된 지역변수에서만 사용가능하다.
- 멤버변수, 메소드의 파라미터, 반환타입 등에는 사용할 수 없다.
