- 프리미티브 타입과 레퍼런스 타입

  자바 타입은 크게 두 가지의 종류가 있으며, 이는 primitive type과 reference type으로 나뉜다.

- **프리미티브 타입 종류와 값의 범위 그리고 기본 값**

  * Primitive type은 자바의 기본 타입들이며 총 8개가 존재한다.
    필드 선언 시 초기화를 진행하지 않을 경우, 기본 값으로 초기화 되어 유의미한 값을 가지게 된다.

  * Stack영역에 저장된다.

  * 정수 타입(byte, char, short, int, long)

    * 기본적으로 자바는 int타입으로 정수 연산을 수행함.
    * byte나 short를 사용할 경우, 메모리 절약이라는 장점이있으나 값의 범위가 작아 범위 초과 시 잘못된 결과를 얻을 수 있는 단점이 존재한다.

    

    * byte: 1byte 범위의 수 저장. 

      색상 정보 및 파일 또는 이미지 등의 이진(binary) 데이터를 처리할 때 주로 사용된다.

    * short: 2byte로 표현되는 정수값을 저장할 수 있는 데이터 타입.

      C언어와의 호환을 위해 사용하고 비교적 자바에서 잘 사용하지 않는다.

    * int: 자바에서 정수 연산을 하기 위한 기본 타입. 4byte로 표현되는 정수값을 저장할 수 있다.

      byte나 short 타입의 변수를 더하는 연산을 진행 할 경우, int로 변환 되기 때문에 나온 결과도 int가 된다.

    * long: 8byte로 표현되는 정수값을 저장할 수 있는 데이터 타입.

      수치가 큰 데이터를 다룰 경우 필수적으로 사용되며, 변수 초기화 시 정수값 뒤에 l혹은 L을 붙일 수 있다.

      int 타입의 범위가 넘어갈 경우 오류가 생길 수 있기 때문에 반드시 넣어줘야한다.

    

  * char 타입

    * 자바는 모든 문자를 유니코드로 처리하며, 유니코드는 세계 문자들을 코드 값으로 매핑한 국제 표준 규약이다.
      유니코드는 음수가 없기에 음수 값을 지정할 수 없다.
    * 직접 유니코드 혹은 정수값을 지정하거나, 'a'와 같이 문자를 입력할 수 있다.

    

  * 실수 타입(float, double)

    * 소수점이 있는 실수 데이터를 저장할 수 있는 타입이며, 메모리 사용 크기에 따라 float와 double로 나뉜다.
    * 큰 쪽이 double, 작은 쪽이 float이다.

    

    * float: 4byte로 표현되는 부동 소수점 타입. 유효 숫자 범위는 6~7자리의 정밀도를 가진다.

      부동 소수점의 값에 f혹은 F를 붙여서 표현한다.

    * double: 8byte로 표현되는 부동 소수점 타입. 유효 숫자 범위는 15자리의 정밀도를 가진다.

      부동 소수점 값은 기본적으로 double형을 사용하지만, d혹은 D를 사용해 표현할 수도 있다.

    

  * 논리 타입(boolean)

    * 1byte(8bit)로 표현되는 논리값(true/ false)을 저장할 수 있다.
    * 상태값에 따라 조건문과 제어문의 실행 흐름을 변경하는 데 주로 사용된다.

    

  | 타입    | 설명               | 사이즈 | 값의 범위                    | 기본 값  |
  | ------- | ------------------ | ------ | ---------------------------- | -------- |
  | byte    | 부호가 있는 정수값 | 8bit   | -128~ 127                    | 0        |
  | short   | 부호가 있는 정수값 | 16bit  | -32768~ 32767                | 0        |
  | int     | 부호가 있는 정수값 | 32bit  | -2147483648~ 2147483947      | 0        |
  | long    | 부호가 있는 정수값 | 64bit  | -2^63 ~ (2^63 -1)            | 0L       |
  | char    | 유니코드 문자      | 16bit  | '\u0000' ~ '\uffff'/ 0~65535 | '\u0000' |
  | float   | 부동소수점 수      | 32bit  | 2-149 ~ (2-2-23)*2127        | 0.0d     |
  | double  | 부동 소수점 수     | 64bit  | 2-1074 ~(2-2-52)*21023       | 0.0d     |
  | boolean | 논리 값            | 1bit   | true / false                 | false    |

  

- **레퍼런스 타입**

  * primitive type을 제외 한 모든 타입들이 해당된다.

  * 레퍼런스 타입의 경우, 변수 선언 시 바로 변수에 값이 저장되는 것이 아닌, 객체에 대한 힙 영역의 참조 주소값을 저장하게 된다.

    자바의 참조는 C/C++에 있는 포인터와 같은 것이 아니기 때문에, 개발자는 직접적으로 메모리에 접근해 이를 조작할 수 없다.

    > 참조를 저장한다?
    >
    > 두 변수가 같은 참조를 가리키고 있는 경우, 한 쪽 변수가 객체의 상태를 변경 시 다른 한 쪽도 영향을 받을 수 있다는 의미다.

  * 참조 타입의 변수는 Heap Area의 객체를 참조하지 않는다는 의미로 null값을 가질 수 있다.

    null값으로 초기화 된 참조변수는 초기값으로 사용할 수 있기 때문에 스택 영역에 생성된다.

  * 참조 타입의 변수를 사용 할 때 참조할 객체가 없어 사용할 수 없을때 나오는 에러가 NullPointException이다.

- 리터럴

  * 프로그램에서 직접 표현한 값으로, 소스 코드의 고정 된 값을 대표하는 용어다.

  * 종류

    * 정수 리터럴: 10진수, 8진수, 16진수, 2진수 리터럴

      ```java
      int a = 15;   	// 10진수 리터럴 15
      int b = 015;  	// 0으로 시작한다면 8진수. 10진수 값으로 13 출력
      int c = 0x15; 	// 0x로 시작한다면 16진수. 10진수 값으로 21 출력
      int d = 0b0101; // 0b로 시작하면 2진수. 10진수 값으로 5 출력 
      ```

      정수 리터럴은 int형으로 컴파일 되믈, long타입 리터럴은 숫자 뒤에 L 또는 l을 붙여 표시한다.

      `long e = 15L;`

    * 실수 리터럴: 소수점 형태나 지수 형태로 표현한 값으로, double 타입으로 컴파일 된다.

      ```java
      double f = 0.1234;
      double g = 1234E-4; // E혹은 e가 붙을 경우, 10진수 지수와 가수로 간주한다. 
      // 따라서 1234*0.1^4 이므로 0.1234와 동일하다.
      ```

      float의 경우, 값 뒤에 f혹은 F를 반드시 붙여줘야 하며, double은 생략할 수 있다.

    * 문자 리터럴: 문자 리터럴을 저장할 수 있는 타입은 char하나 뿐이며, 단일 인용부호(' ')로 문자를 표현한다.

      ```java
      char a = 'H';
      char c = \uae00; //유니코드 값. \u 다음에 4자리 16진수로, 2바이트의 유니코드 값이 된다.
      ```

      역슬래시(\\)가 붙은 문자 리터럴은 이스케이프(escape)문자라고도 하는데, 다음과 같은 용도로 사용됨.

      | 이스케이프 문자 | 용도                       | 유니코드        |
      | --------------- | -------------------------- | --------------- |
      | '\t'            | 수평 탭                    | 0x0009          |
      | '\n'            | 줄 바꿈                    | 0x000a          |
      | '\r'            | 리턴                       | 0x000d          |
      | '\"'            | "(큰 따옴표)               | 0x0022          |
      | '\''            | '(작은 따옴표)             | 0x0027          |
      | '\\'            | \(역 슬래시)               | 0x005c          |
      | '\u16진수'      | 16진수에 해당하는 유니코드 | 0x0000 ~ 0xffff |

    * 문자열 리터럴: 기본 타입이 아니며, 큰 따옴표(" ")로 묶은 텍스트는 문자열 리터럴로 간주한다. 이는 텍스트가 존재하지 않아도 동일하다.

      문자열 리터럴 안에서도 이스케이프 문자를 사용할 수 있다.

      문자열 리터럴을 저장할 수 있는 타입은 String 하나 뿐이다.

      ```java
      String a = "안녕하세요\n";
      ```

    * 논리 리터럴: boolean 타입 변수에 치환하거나 조건문에 이용된다.

      ```java
      boolean a = true;
      boolean b = 10 > 0; // 이 때, b의 값은 true.
      ```

    * 그 외의 리터럴: null 리터럴이 존재하며, 레퍼런스에 대입해서 사용된다.

      Class리터럴도 존재하는데, `[type 명].class` 형태로 표현된다.

- 변수 선언 및 초기화하는 방법

  > 변수란? 
  >
  > 하나의 값을 저장할 수 있는 메모리 공간.
  >
  > 프로그램에 의해 수시로 값이 변동될 수 있기 때문에 변수라고 한다.
  >
  > 정수 타입 변수에는 정수만, 실수 타입 변수에는 실수 값만 저장 가능하다.

  * 선언 방법: 어떤 타입의 데이터를 저장할 것인지, 그리고 변수의 이름은 무엇인지 결정해야한다.

    ```java
    int a; // 정수 값을 저장하는 a변수 선언
    double b; // 실수 값을 저장하는 b변수 선언
    
    int x,y,z // 같은 타입의 경우, 콤마(,)로 한번에 선언할 수 있다.
    ```

  * 초기화 방법: 변수에 값을 저장할 때에는 대입연산자(=)를 사용한다.

    대입 연산자 기준 우측의 값을 좌측의 변수에 저장한다는 의미를 가지며, 이러한 방법으로 처음 값을 지정 할 경우, 이를 초기값이라고 부른다.

    초기값을 주는 행위를 초기화 라고 한다.

    ```java
    int team; // 변수 선언
    team = 1; // 변수 초기화
    
    int score = 90; // 변수 선언과 동시에 초기화
    ```

    

- 변수의 스코프와 라이프타임

  > 스코프?
  >
  > 변수에 접근하고, 접근할 수 있는 영역을 스코프라고 한다.

  * 변수는 중괄호 {} 블록 내에 선언되고 사용된다.

  * 변수가 선언된 위치에 따라 세가지 영역으로 나뉜다.

    * Local Variable (지역 변수)

      * 정해둔 지역, 즉 함수(Method) 내부에서 사용 가능한 변수.
      * 정해진 메서드 밖에선 사용할 수 없으며, 호출 될 경우 스택(Stack) 메모리에 생성된다.
      * 메서드 종료 시, 스택이 사라지고 동시에 그 안에 선언된 변수들도 사라진다.
      * 메서드 내에서만 사용되기 때문에 각각 다른 메서드라면 이름이 같아도 다른 변수로 인식된다.
      * **라이프타임** : 변수가 선언되고, 선언된 블록을 벗어날 때 까지.

    * Instance Variable (멤버 변수)

      * new 키워드로 인스턴스를 생성할 경우, 함께 생성된다. static이 붙지 않고 생성된 변수를 의미한다.

        인스턴스 별로 다른 값을 가질 수 있기 때문에 인스턴스 변수라고 불린다.

      * heap 메모리에 생성되며, 해당 클래스의 메서드에서 사용이 가능하다. heap영역에 생성되었기 때문에, 특정한 시점에서 가비지 컬렉터(Garbage Collector)에 의해 수거된다.

      * 접근 제어자가 public일 경우, 같은 패키지의 다른 클래스에서도 사용이 가능하지만, private일 경우, 별도의 getter, setter와 같은 메서드를 이용 해야지만 다른 클래스에서 접근 할 수 있어 보안성이 좋아진다.

      * **라이프타임** : 인스턴스가 생성되고 해제 될 때 까지. 인스턴스 메모리가 살아있는동안은 사용할 수 있다.

    * Class Varialble (static 변수)

      * static 예약어를 붙이면 사용이 가능하고, 클래스를 메모리에 로드했을 때 부터 생성되는 변수를 의미한다.

        인스턴스를 new 로 생성하지 않아도 사용할 수 있다.

      * data영역에 생성된다.

      * 프로그램이 실행되고 종료될  때 까지 메모리를 점유하고 있기 때문에, 남발 시 시스템의 메모리를 낭비할 수 있기 때문에 사용시 주의가 필요하다.

      * public과 함께 사용 할 경우, 전역 변수로 만들 수 있다.

      * 보통 중복된 멤버변수를 대체하기 위하여 사용되는 경우가 많다.(중복 멤버변수를 100개 만드는 것 보다 static 변수를 한 개 만드는 것이 효율적이기 때문.)

      * **라이프타임** : 프로그램이 실행되고 종료될  때 까지 사용할 수 있다.

- 타입 변환, 캐스팅 그리고 타입 프로모션

  * 타입변환: 데이터 타입을 다른 데이터 타입으로 변환하는 것. 두가지 종류가 존재한다.

    * 자동(묵시적) 타입 변환: 

      자동 타입의 경우, 확장이라고도 한다. 두 데이터 타입이 자동으로 변환되는 변환 방법이다.

      확장이라고 하는 이유는, 두 데이터 타입 중 작은 데이터 타입의 값을 더 큰 범위의 타입에 할당하기 때문이다.

      `byte > short > int > long > float > double` 순으로 자동 형변환이 된다.

      

    * 강제(명시적) 타입 변환 (캐스팅: casting):

      축소 라고도 하며, 자동 타입 변환과는 반대로 더 큰 타입의 데이터 타입이 작은 타입의 데이터로 형변환 하는 변환 방법이다.

      호환되지 않는 데이터 타입에도 사용할 수 있으며, 반드시 형변환을 명시 해 줘야 한다.

      ```java
      char ch = 'a';
      int num = 13;
      ch = (char)num;
      
      double doublenum = 3.14;
      int num = (int)doublenum // 이 경우 정수 부분인 3으로 저장됨.
      ```

      다만 이 경우, 작은 타입의 데이터가 표현할 수 **없는** 범위일 경우 값이 변경 될 수 있으니 주의가 필요하다.

  * 타입 프로모션:

    * 프로그램 실행 도중, 자동적으로 타입 변환이 일어나는 것을 의미한다.

    * 연산을 하는 경우, 피연산자의 범위를 초과할 수 있기 때문에 자동으로 값이 승격되는 것을 타입 프로모션이라 한다.

      ```java
      byte b = 42;
      int i = 100;
      
      int result = b * i;
      ```

      

- 1차 및 2차 배열 선언하기

  * 1차원 배열 선언:

    ```java
    public int[] numbers = {1,2,3,4,5}; 
    public String[] strArr = {"안녕하세요", "자바 스터디 그룹", "never-ending-srory", "입니다"};
    
    public int[] numbers2 = new int[5]; // 0으로 초기화 된, 5개의 값을 저장할 수 있는 배열이 생성됨
    public String[] strArr2 = new String[4]; // null로 초기화 된, 4개의 값을 저장할 수 있는 배열생성
    ```

    * 단순 선언만 할 경우, 사용할 수 없으니 `new int[10]` 과 같이 초기화를 해주거나, 중괄호 안에 값을 넣어 초기화와 배열 생성을 함께 할 수 있다.

      중괄호를 이용한 배열 생성의 경우, 중괄호 안의 값의 갯수로 배열의 크기가 결정된다.

    * 배열의 요소에는 인덱스로 접근할 수 있으며, 인덱스는 0부터 시작한다.

    * 배열도 객체로 인식되며, new 연산자로 생성되기 때문에 힙 영역에 배열이 생성된다. 

  * 2차원 배열 선언:

    ```java
    int[][] ints = new int[10][10];
    
    String[][] names = {
      {"Kim","Park","Jung"},
      {"Nam","Hayeon","Jiwon"}
    }
    ```

    * 이차원 배열도 요소의 인덱스로 접근할 수 있다.

      ```java
      String name = names[0][0] + names[1][0] // Kim Nam 
      ```

  * 배열의 크기는 `arr.length`로 알 수 있다.

  * 초기화 하면 크기를 변경할 수없으며, 만일 변경하고 싶은 경우 더 큰 배열을 만들어 배열의 안의 값을 복사하여 넣어줘야한다.

  

- 타입 추론, var

  * 타입 추론: 

    * 타입을 미리 선언하지 않고 리터럴 값으로 컴파일러가 추론하게 하는 것.

    * 개발자가 필요하지 않은 지역 변수 유형의 매니페스트 선언을 제거할 수 있도록 함으로써 중복을 줄여서 가독성을 향상시키려는 것이 주 목적이다.

      ```java
      Map<String, List<String>> myMap = new HashMap<>();
      List<String> list = new ArrayList<>();
      ```

  * Var:

    * var는 타입의 이름이며 지역 변수 유형 추론을 허용하기 때문에, 컴파일러가 지역변수의 유형을 추론한다.

    * 지역 변수 타입을 추론하기에 충분한 정보가 존재해야하며, 충분한 정보가 없을 경우 컴파일러에서 오류가 발생한다.

      ```java
      var str = "Java" // 문자열 추론
      var list = new ArrayList(); // ArrayList 추론
      ```

    * 사용 할 수 없는 경우는 다음과 같다.

      * 필드 혹은 메서드 시그니처에서 사용이 불가능하다. 지역 변수에만 사용 가능.

        `public void count(var list) { }`

      * 명시적 초기화 없이, 단독으로 선언 할 수 없다.

        `var x;`

      * null로 초기화 할 수 없다.

      * 어떤 타입인지 알 수 없을 때는 사용할 수 없다.

        `var data = getCount();`

      * 배열 초기화를 사용 할 경우, 명시적인 대상 유형이 필요하다.

        ```java
        var arr = {1,2,3};
        ```

      * 람다식의 경우, 자바 11버전 부터 var를 사용 할 수 있으나, 다른 타입과 섞어서 쓰는 것은 불가능 하다.

        ```java
        (var x, y) -> x.process(y)
        (var x, int y) -> x.process(y)
        ```

        >  참조: http://openjdk.java.net/jeps/323

