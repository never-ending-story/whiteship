### **프리미티브 타입 종류와 값의 범위 그리고 기본 값**

![https://user-images.githubusercontent.com/59776016/125828948-ade06263-2549-41fe-b93d-09e2107c1cc9.png](https://user-images.githubusercontent.com/59776016/125828948-ade06263-2549-41fe-b93d-09e2107c1cc9.png)

**범위가 위와 같이 결정되는 이유**(라이브): 바이트를 예로 들어, 바이트의 메모리 범위 = 1byte = 8bit, 즉, 표현 가능한 값의 개수는 개. 하지만 왜 범위가 0~256이 아닐까? 음수를 표현하기 위해 MSB(abb. for Most Significant Bit, 최상위 비트), 일반적으로 가장 왼쪽에 위치한 비트를 부호 비트로 사용하는데 1이면 음수, 0이면 양수를 나타낸다. 이렇게 되면 0을 포함한 -128~127까지 개의 값을 나타낼 수 있게 된다.

- byte, short: byte와 마찬가지로 적은 메모리를 차지하기 때문에 용량이 중요하던 과거에는 많이 쓰였지만 요즘은 정수형은 대부분 `int`형을 쓴다.
- float: 정수형을 표현할 때 메모리를 아끼기 위해 int타입 대신 byte나 short를 쓰는 것처럼 float은 실수형을 표현할 때 double 대신 메모리 사용을 줄이기 위해 쓰인다. 화폐와 같이 정확한 값이 요구되는 상황에서는 float을 쓰면 안되고 BigDecimal을 쓸 것.
- double: float과 마찬가지로 정확한 값이 요구되는 상황에서 쓰이기 적합하지 않다. float보다 메모리를 두배 차지한다고 double이란다.
- boolean: 참과 거짓을 나타낼 수 있다.
- char: 자바에서는 문자를 나타낼 때 유니코드(2byte 문자체계)를 사용한다.

### **프리미티브 타입과 레퍼런스 타입**

자바에서의 데이터 타입은 크게 기본형과 참조형으로 나뉜다. 기본형은 위에서 나와있는 논리형(boolean), 4개의 정수형(byte, short, int, long), 2개의 실수형(float, double)과 문자형(char)로 이루어져 있다. 이 여덟개의 데이터 타입을 제외한 모든 데이터 타입을 레퍼런스 타입, 참조형이라고 한다.

기본형 변수는 할당된 값 자체를 저장하지만 참조형은 객체의 주소를 저장한다.

그래서 참조형은 변수를 선언할 때 제일 먼저 데이터 타입과 변수의 이름을 지정해주는데 이 부분은 사실상 실제 객체가 아닌 해당 데이터 타입의 객체의 주소값을 담을 저장공간을 마련해주는 것이다. 그리고 뒤에 따라오는 `new` 키워드에 따라 객체가 만들어지고 해당 객체의 주소값이 앞에서 선언한 변수에 저장된다.

자바의 클래스, == 데이터타입,은 모두 `Object` 클래스를 상속받지만 기본형은 이에 해당되지 않는다.

### **리터럴**

프리미티브 타입(기본형)은 자바 언어 자체에 내장되어 있기 때문에 `new` 키워드를 사용하지 않아도 된다(클래스로부터 생성된 객체가 아니라는 뜻이기도 하다).

기본형 변수를 선언할 때에는 `int number = 1;`과 같은 식으로 표현되는데 여기서 equal sign 뒤에 나오는 숫자 1을 literal이라 칭한다(원래 단어의 뜻만 본다면 constant가 더 적합하겠지만 자바에서 constant는 다른 의미를 뜻하기 때문에 -a variable whose value cannot change once it's been assigned, or any value with `final` keyword- literal이라고 칭하는 것 같다).

```java
int number = 1; // literal: 1
char c = 'c'; // literal: c
string s = "sally"; // literal: sally
```

정수형을 나타낼 때에는 이진법, 십진법, 팔진법, 16진법을 이용해 표기할 수 있지만 실수형은 십진법만 받아드려진다. 또한 자바 7부터 정수형 리터럴 중간에 구분자('_')를 넣을 수 있게 되어서 큰 수를 보다 쉽게 읽을 수 있게 되었다.

- 이진법: prefix `0b`나 `0B`를 붙여야 한다.
- 팔진법: prefix `0`을 붙여야 한다.
- 16진법: prefix `0x`나 `0X`를 붙이고 원래의 16진법 표기법으로 표기한다. 자바는 원래 case sensitive한 언어지만 16진법에서는 대/소문자 구분을 하지 않는다.
- float: suffix `f`나 `F`를 붙인다. 실수형은 기본 자료형이 double이므로 더블에는 따로 접미사를 붙일 필요가 없다.

문자형(char)의 경우 작은 따옴표 안에 넣거나('a'), 정수형을 이용해 표기하거나(0~65535 범위 내), 유니코드 표기법을 이용한다. char의 경우 기본형이므로 빈 문자를 허용하지 않지만 String 타입은 빈 문자열이 허용되므로 참고하자.

불린 타입의 경우 true 혹은 false여야 하며 0이나 1은 정수형으로 받아드려진다.

### **변수 선언 및 초기화하는 방법**

변수란 위에서도 말했든 값을 저장할 수 있는 저장공간이다. 그래서 변수의 `(저장할 변수의 타입 이름) (변수이름)`과 같이 선언된다.

반면 초기화는 선언된 변수에 값을 지정해주는 행위이다. 자바에서는 대입 연산자인 `=`를 이용해 값을 대입해준다.

```java
int number; // int타입의 number 변수 선언
number = 123; // number 변수에 값 123 저장(초기화)

int number2 = 321; // 변수와 선언을 한 줄에 표현
```

여기까지는 값 자체를 저장하는 기본형의 변수 선언 및 초기화 방법이었고 참조형의 경우 객체를 해당 데이터 타입의 생성자에 맞게 생성해야하므로 `new` 키워드가 필요하다. `new` 키워드가 나오는 시점에 해당 타입의 객체를 저장할 메모리를 할당받는다. 그 후 생성자가 따라오는데 생성자에서 객체가 초기화된다.

```java
Member member = new Member(); // Member 클래스가 가진 생성자에 따라 필요한 파라미터가 달라지게 된다.
Member member2 = new Member("sally");
```

### **변수의 스코프와 라이프타임**

변수는 크게 세 종류로 나눌 수 있다: 인스턴스 변수, 클래스 변수, 로컬 변수.

- 인스턴스 변수: 클래스 안, 메서드 밖에 선언된 변수/`static` 키워드가 붙지 않은 필드
  - 생성된 인스턴스별로 가지는 인스턴스 변수의 값이 다를 수 있다.
  - 초기화가 되어있지 않아도 기본 값을 가진다.
  - 인스턴스가 생성될 때 생성되며 객체를 참조하는 변수가 없을 경우 GC가 제거한다.
- 클래스 변수: 클래스 안에 선언된 `static` 키워드를 가진 필드
  - 인스턴스화 됨과 상관없이 한 값만 가진다.
  - 초기화가 되어있지 않아도 기본 값을 가진다.
  - 클래스가 메모리에 올라갈 때 생성되고 프로그램이 종료될 때까지 존재한다.
  - 클래스를 기반으로 생성된 인스턴스에 공유되므로 클래스 전역으로 쓸 수 있다.
- 로컬 변수: 메서드 안에 선언된 변수, 로컬 변수임을 판명짓는 특별한 키워드는 없다.
  - 메서드 안에 선언된 로컬 변수는 해당 메서드 외부에서는 접근할 수 없다.
  - 초기화는 필수! `variable might not have been initialized`라고 뜬다
  - 메서드 내부에서 선언될 때 생성되며 메서드가 끝나는 브라켓 `}`에서 소멸된다.

### **타입 변환, 캐스팅 그리고 타입 프로모션**

타입 변환이란 말 그대로 데이터 타입을 바꿔주는 것을 칭한다. 타입 프로모션은 보다 적은 범위의 타입에서 더 넓은 범위의 타입으로 widening하는 것이고 타입 캐스팅은 반대로 넓은 범위의 타입에서 적은 범위의 타입으로 narrowing하는 것을 말한다. 기본적으로 프로모션은 적은 범위에서 넓은 범위로 가는 것이기 때문에 데이터가 손상되는 등의 문제는 일으키지 않아 자유로운 편이지만 캐스팅은 많은 정보를 가진 데이터가 좁은 범위의 데이터 타입으로 변환되는 것이기 때문에 데이터의 유실이 있을 수 있다.

- 기본형의 타입 변환

  - 프로모션: 기본형의 프로모션의 경우 그냥.. 써주면 된다.

    ```java
    int a = 1;
    long longA = a; // 이렇게..
    
    double b = 1L; // 아님 이렇게..
    ```

    - byte(8bits), short(16bits), char(16bits), int(32bits), long(64bits), float(32bits), double(64bits) 순서대로 프로모션이 가능하다
    - 쓰다보니 사이즈는 long이 더 큰데 어떻게 long → float이 캐스팅이 아닌 프로모션이 될 수 있지? 라는 생각이 들어서 찾아보니 `int -> float`, `long -> float`, `long -> double`의 경우에는 정확도가 떨어지는 것을 어느정도 감수하고 프로모팅을 하는 거라고 한다. 그래서 금융권 같은 곳에서는 float이나 double을 쓰지 않는다고 얘기하는 건가 싶기도 했다.

  - 캐스팅: 초기화 해줄 때 캐스팅하고싶은 타입을 괄호 안에 써준다(이를 써줌으로 데이터 값의 손실이나 정보의 손실을 감수한다는 것을 명시적으로 표현한다).

    ```java
    int a = (int) 1L;
    byte b = (byte) a;
    ```

- 참조형의 타입 변환: 참조형은 객체 그 자체를 값으로 가지는 게 아니라 객체의 주소를 값으로 가지고 있어서 캐스팅 방식이 다르다.

  - 업캐스팅: 서브 클래스에서 수퍼 클래스로 캐스팅하는 것.

    - 수퍼 클래스 `Animal`과 이를 상속받는 서브 클래스 `Cat`이 있다고 가정할 때 `Animal` 클래스의 변수가 `Cat` 의 객체를 암시적으로(implicitly) 업캐스팅 할 수 있다.

      ```java
      public class Animal {
      	public void eat() {
      		System.out.println("Animal is eating")
      	}
      }
      
      public class Cat extends Animal {
      	public void eat() {
      		System.out.println("Cat is eating")
      	}
      	public void meow() {}
      }
      
      public class Dog extends Animal {
      	public void eat() {
      		System.out.println("Dog is eating")
      	}
      	public void bark() {}
      }
      
      public static void main(String[] args) {
      	Cat cat = new Cat();
      	Animal animal = cat; // 암시적으로 업캐스팅
      }
      ```

    - 기본형을 캐스팅하듯이 명시적으로(explicitly) 참조(`animal = (Animal) cat`) 할 수도 있지만 여기서 cat은 `Animal` 클래스를 상속받은 `Cat` 클래스의 인스턴스이므로 상속관계에 있는 클래스들을 굳이 (괄호까지 쳐가며) 캐스팅할 필요는 없다.

    - 대신 animal 변수에서 사용할 수 있는 cat의 메서드는 줄어든다. 캣 클래스에 있는 meow 메서드는애니멀 클래스에는 존재하지 않는다. 수퍼 클래스에서 define되지 않은 메서드나 필드는 사용하는데 제한이 있다.

    - 자바에 존재하는 모든 클래스는 `Object` 클래스를 상속받기 때문에 모든 클래스의 객체는 `Object` 변수에, 또 해당 클래스가 상속받는 모든 클래스의 변수에 참조될 수 있다.

    - 위의 예제에서 Cat을 참조하는 Animal 변수로 `eat()`을 실행시킨다면 참조되는 실제 객체(Cat의 객체)의 메서드(오버라이드된 `eat()`)이 실행되고 `Cat is eating`이 출력된다.

  - 다운캐스팅: 수퍼 클래스에서 서브 클래스로 캐스팅하는 것

    - 애니멀타입의 변수에 캣 객체를 저장한다고 하자(`Animal animal = new Cat();`). Cat 객체를 참조하고는 있지만 캣 클래스에 있는 `meow()` 메서드는 쓸 수 없다. 이 때 다운캐스팅을 하면(`((Cat) animal).meow();`) animal 앞의 괄호가 캐스팅 연산을 하게되고 meow() 메서드를 쓸 수 있게 된다.

### **1차 및 2차 배열 선언하기**

배열의 선언과 생성은 다음과 같이 할 수 있다.

```java
int[] array;
int array2[]; // 참조변수의 선언.

array = new int[3]; // 변수이름 = new 배열타입[길이];
array2 = {1, 2, 3}; // 이렇게 바로 값을 넣어줄 수도 있다.
```

배열의 경우 생성과 동시에 배열의 사이즈(length)가 고정으로 정해진다. 참조형과 마찬가지로 변수는 그저 실제 배열의 참조값을 가질 뿐(가리킨다)이고 실제 배열은 초기화 시켜주어야 메모리가 할당되고 생성된다. 배열의 사이즈가 고정되는 이유는 메모리에 physically 배열이 붙어있기 때문이다. 따라서 배열의 사이즈를 변경하고 싶다면 원하는 사이즈의 배열을 새로 만들어 메모리를 새로 할당받고 기존의 배열 값을 카피해와야 한다.

2차 배열도 비슷하다.

```java
int[][] array2D;
int array2D2[][];

array2D = new int[3][3];
array2D2 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
```

### **타입 추론, var**

자바 10부터 타입 추론이 가능해졌다. 하지만 $^{1.}$ 선언과 동시에 초기화 필수(null값은 허용되지 않음) $^{2.}$ 멤버 변수로는 사용할 수 없음 $^{3.}$ 지네릭 타입에 사용할 수 없음 $^{4.}$ 람다식에 쓸 수 없음 $^{5.}$ 파라미터나 리턴 타입으로 지정될 수 없음 과 같은 제약사항이 많다. 초기화가 필수라는 말은 어떻게 보면 타입을 명시적으로 추론할 수 있어야 한다는 말인데 대체 왜 쓰는걸까..

### **Reference**

> [Literals In Java](https://www.geeksforgeeks.org/literals-in-java/)

> [Scope and Lifetime of a Variable](https://www.learningjournal.guru/article/programming-in-java/scope-and-lifetime-of-a-variable/)

> [Data types - Oracle Java Doc](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)

> [Java Type Casting](https://www.baeldung.com/java-type-casting)


