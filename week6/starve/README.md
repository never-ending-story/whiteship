## 자바 상속의 특징

#### 상속이란?

- 기존의 클래스를 재 사용하여 새로운 클래스를 작성하는 것.

  - 특징:
    - 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있음.
    - 코드를 공통적으로 관리 할 수 있기 때문에 코드의 추가 및 변경이 용이.
    - 코드의 재사용성을 높이고, 중복을 제거하여 프로그램의 생상선과 유지보수에 크게 기여 함.

- 상속을 구현하는 방법: 작성하고자 하는 클래스의 이름 뒤에 상속 받고자 하는 클래스의 이름을 'extends'와 함께 작성 한다.

  ```java
  class Parent { }
  class Child extends Parent {
    // ...
  }
  ```



#### 상속의 특징

* ###### 단일 상속(single inheritance)

  - **자바에서는 단일 상속만을 허용 하기 때문에, 둘 이상의 클래스로부터 상속을 받을 수 없다.**

  - **다중 상속의 경우 :** 
    장점:

    - 여러 클래스로부터 상속 가능하기에, 복합적인 기능을 가진 클래스를 쉽게 작성 가능.

    단점:

    - 클래스 간의 관계가 매우 복잡해짐
    - 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같을 경우, 구별할 수 없음. (해결하는 방법으로는 조상 클래스의 메서드 이름이나 매개변수를 바꾸는 법 밖에 없음. = 굉장히 번거로움.)

    **이러한 문제점이 있기 때문에, 다중 상속의 장점을 포기하고 단일 상속만을 허용 하게 되었다.**

  - **단일 상속이 다중상속보다 유리한 점:**

    - 클래스간의 관계가 보다 명확해짐.
    - 코드를 더욱 신뢰 할 수 있음.

* ###### Object클래스 -모든 클래스의 조상이다.

  모든 클래스의 조상으로 Object가 존재하며, 이는 아래에서 조금 더 자세히 다룰 예정이다.

* ###### 상속 횟수에 제한이 없다.



## super 키워드

#### super() - 조상의 생성자

- this()의 경우, 같은 클래스의 다른 생성자를 호출하는데 사용 되지만, super()는 조상의 생성자를 호출하는 데 사용된다.
- 조상클래스(부모 클래스)의 멤버에 접근할 수 있으며, 메서드 오버라이딩 시 조상클래스의 메서드를 호출해서 사용할 수 있다.
- super키워드를 통해, 서브클래스는 부모 클래스의 생성자를 호출 할 수 있다.



## 메소드 오버라이딩

#### 오버라이딩이란?

- 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것.

- 상속받은 메서드를 그대로 사용하기도 하지만, 자손 클래스에 맞게 변형해야하는 경우 조상의 메서드를 오버라이딩 함.

- 예제: Point의 경우, 2차원 좌표계의 한 점을 표현 하지만, Point3D의 경우, 3차원 좌표계의 한 점을 표현하기 위한 것이기 때문에 오버라이딩 함.

  ```java
  class Point {
    int x;
    int y;
    
    String getLocation() {
      return "x:" +x +",y:" +y;
    }
  }
  
  class Point3D extends Point {
    int z;
    
    String getLocation() { // 오버라이딩
    return "x:" +x +",y:" +y + ",z:"+z;
  }
  ```

  

  - Point 클래스를 사용하던 사람들은, 새로 작성 된 Point3D클래스가 Point클래스의 자손이므로, Point3D클래스의 인스턴스에 대해 getLocation()을 호출 시, 점의 좌표를 문자열로 얻을 수 있을 것이라 기대하기 때문에, 
    **새로운 메서드를 제공하는 것 보다 오버라이딩을 하는 것이 바른 선택.**

#### 오버라이딩의 조건

- 메서드의 내용만을 새로 작성하는 것 이므로
  1. **메서드의 선언부(메서드 이름, 매개변수, 반환타입)는 조상의 것과 완전히 일치해야한다.**
- 접근제어자(access modifier)와 예외(exception)는 제한된 조건 하에서만 다르게 변경 가능.
  1. **접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.** 만일 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 이를 오버라이딩 하는 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 한다. 보통 같은 범위의 접근제어자 사용.

> public > protected > (default) > private 순.

* **조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.**
  * 오버라이딩의 바른 예시:

  ```java
  class parent { // 조상메서드
    void parentMethod() throws IOException, SQLException { // 예외가 2개
      ...
    }
  }
  
  class Child extends Parent { // 자손 메서드
    void parentMethod() throws IOException { // 예외가 1개
      ...
    }
    ...
  }
  ```



## 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)

* #### 다이나믹 메소드 디스패치란?

  * 자바의 테크닉 중 하나로, 런타임에 오버라이딩 된 메서드가 실행되는 것을 의미한다.
    참조 타입이 부모 타입인 경우에도 동작하므로, 런타임 시점에 다형성을 만족하게 할 수 있다.

  ```java
  public class Car {
    public void move() {
      System.out.println("차가 움직입니다")
    }
  }
  
  public class Bus extends Car {
    @Override
    public void move() {
      System.out.println("버스가 움직입니다")
    }
  }
  
  public class Main {
    Car a = new Car(); // Car참조, Car객체
    Car b = new Bus(); // Car참조, Bus객체
    
    a.move(); // Car 클래스에 정의된 메서드 실행
    b.move(); // Dog 클래스에 정의된 메서드 실행(다이나믹 메소드 디스패치)
  }
  ```

  실행 시, b의 경우 Bus 클래스에 정의된 move메서드가 실행된다.
  컴파일 타임에는 참조 타입만 확인하지만, JVM이 객체의 타입을 파악하고 그 객체에 정의된 메서드를 실행한다.



## 추상 클래스

- abstract는 '미완성'의 의미를 가지고 있다.

- 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용되는 키워드.

- 클래스에 추상 메서드가 포함되어있는 경우, 그 클래스는 반드시 추상클래스어야 한다.

- **abstract가 사용될 수 있는 곳 - 클래스, 메서드**

  | 제어자   | 대상   | 의미                                                         |
  | -------- | ------ | ------------------------------------------------------------ |
  | abstract | 클래스 | 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.          |
  | abstract | 메서드 | 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다. |

```java
abstract class AbstractTest { // 추상 클래스(추상 메서드를 포함한 클래스)
  abstract void move();				// 추상 메서드(구현부가 없는 메서드)
}
// 추상 클래스는 아직 완성되지 않은 메서드가 존재하므로, 인스턴스를 생성할 수 없다.
AbstractTest a = new AbstractTest(); // 에러. 추상 클래스의 인스턴스 생성 불가
```



## final 키워드

- final은 '마지막의' 또는 '변경될 수 없는'의 의미를 가지고 있음.

- 거의 모든 대상에 사용될 수 있음.

- 변수에 사용될 경우, 값을 변경할 수 없는 상수가 되며, 메서드에 사용될 경우, 오버라이딩을 할 수 없게 되고, 클래스에 사용되면 확장하는 자손클래스를 정의하지 못하게 된다.

- **final이 사용될 수 있는 곳 -클래스, 메서드, 멤버변수, 지역변수**

  | 제어자 | 대상     | 의미                                                         |
  | ------ | -------- | ------------------------------------------------------------ |
  | final  | 클래스   | 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다. 그래서 final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다. |
  | final  | 메서드   | 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없다. |
  | final  | 멤버변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.   |
  | final  | 지역변수 | 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.   |

```java
final class FinalTest {			 // 조상이 될 수 없는 클래스
  final int MAX_SIZE = 10;   // 값을 변경할 수 없는 멤버변수(상수)
  
  final void getMaxSize() {  // 오버라이딩 할 수 없는 메서드(변경 불가)
    final int LV = MAX_SIZE; // 값을 변경할 수 없는 지역변수(상수)
    return MAX_SIZE;
  }
}
```



## Object 클래스

#### Object 클래스란?

- 모든 클래스 상속계층도의 최상위에 있는 조상 클래스.

- 다른 클래스로부터 상속받지 않은 모든 클래스들을 자동적으로 Object클래스로부터 상속 받게 함.

  ```java
  class Tv {
    ...
  }
  
  // 위 코드를 컴파일 할 경우, 컴파일러는 다음과 같이 자동적으로 'extends Object'를 추가.
  // 이미 어떤 클래스로부터 상속 받은 경우, 위의 항목을 추가하지않는다.
  
  class Tv extends Object {
    ...
  }
  ```

- Object클래스의 상속계층도는 다음과 같다.
   [![Obj 상속계층도](https://user-images.githubusercontent.com/69128652/92083673-52d09200-ee01-11ea-9616-08eea634288d.png)](https://user-images.githubusercontent.com/69128652/92083673-52d09200-ee01-11ea-9616-08eea634288d.png)

- 그간 toString()이나 equals(Object o)와 같은 메서드를 따로 정의 하지 않고 사용 가능 했던 이유는, 이 메서드들이 Object클래스에 정의된 것이기 때문이다.

- **주요 메소드**

  | **메소드**                 | **설명**                                                     |
  | -------------------------- | ------------------------------------------------------------ |
  | protected Object clone()   | 현재 객체와 똑같은 객체를 만들어서 반환한다.                 |
  | boolean equals(Object obj) | obj가 가리키는 객체와 현재 객체를 비교한다. 두 객체의 내용을 비교한다. 즉 동등성을 비교한다. (온전히 같은 객체인지 확신 불가능.) |
  | Class getClass()           | 현재 객체의 런타임 클래스를 반환한다.                        |
  | int hashCode()             | 현재 객체에 대한 hash 코드 값을 리턴한다. native call을 하여 메모리가 가진 hash 주소 값을 출력한다. 두 객체가 같은 객체인지 비교한다. 즉 동일성을 비교한다. |
  | String toString()          | 현재 객체에 대한 문자열 표현을 반환한다. (오버라이딩을 하지 않을 경우, 현재 객체의 이름, hash code를 <br />16진수로 변환하여 반환하기 때문에 toString() 오버라이딩이 필수적이다.) |
  | void notify()              | 현재 객체에 대해 대기하고 있는 스레드를 깨운다.              |
  | void notifyAll()           | 현재 객체에 대해 대기하고 있는 모든 스레드를 깨운다.         |
  | void wait()                | 다른 스레드가 깨울 때까지 현재 스레드를 대기하게 한다.       |



